package digi;

import java.util.*;
import java.security.MessageDigest;

public class DigiSignature {

    // Fast modular exponentiation (O(log exp))
    static long modExp(long base, long exp, long mod) {
        long result = 1;
        long b = base % mod;
        while (exp > 0) {
            if ((exp & 1) == 1) result = (result * b) % mod;
            b = (b * b) % mod;
            exp >>= 1;
        }
        return result;
    }

    // GCD
    static long gcd(long a, long b) {
        while (b != 0) {
            long t = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    // Modular inverse (slow loop version, fine for small numbers)
    static long modInverse(long e, long phi) {
        for (long d = 1; d < phi; d++) {
            if ((d * e) % phi == 1) return d;
        }
        return -1;
    }

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);

        // ----- Sender X -----
        System.out.println("Enter primes for Sender X (p and q): ");
        long p1 = sc.nextLong();
        long q1 = sc.nextLong();
        long n1 = p1 * q1;
        long phi1 = (p1 - 1) * (q1 - 1);
        long e1 = 3;
        while (gcd(e1, phi1) != 1) e1++;
        long d1 = modInverse(e1, phi1);
        System.out.println("X's Public Key (e, n): " + e1 + ", " + n1);
        System.out.println("X's Private Key (d, n): " + d1 + ", " + n1);

        // ----- Receiver Y -----
        System.out.println("\nEnter primes for Receiver Y (p and q): ");
        long p2 = sc.nextLong();
        long q2 = sc.nextLong();
        long n2 = p2 * q2;
        long phi2 = (p2 - 1) * (q2 - 1);
        long e2 = 3;
        while (gcd(e2, phi2) != 1) e2++;
        long d2 = modInverse(e2, phi2);
        System.out.println("Y's Public Key (e, n): " + e2 + ", " + n2);
        System.out.println("Y's Private Key (d, n): " + d2 + ", " + n2);

        sc.nextLine(); // clear newline
        System.out.print("\nEnter message to send (by X): ");
        String message = sc.nextLine();

        // ----- Step 1: Hash the message -----
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] hashBytes = md.digest(message.getBytes("UTF-8"));
        long hashValue = 0;
        for (byte b : hashBytes) hashValue = (hashValue + (b & 0xFF)) % n1;
        System.out.println("\nHashed value (reduced mod n1): " + hashValue);

        // ----- Step 2: Sign the hash using X's private key -----
        long signature = modExp(hashValue, d1, n1);
        System.out.println("Digital Signature: " + signature);

        // ----- Step 3: Encrypt the message using Y's public key -----
        StringBuilder cipherText = new StringBuilder();
        for (char ch : message.toCharArray()) {
            long c = modExp(ch, e2, n2);
            cipherText.append(c).append(" ");
        }
        System.out.println("Ciphertext sent to Y: " + cipherText);

        // ----- Receiver Y -----
        System.out.println("\n--- Receiver Side (Y) ---");

        // Step 1: Decrypt the ciphertext using Y's private key
        String[] cipherParts = cipherText.toString().trim().split(" ");
        StringBuilder decryptedMsg = new StringBuilder();
        for (String part : cipherParts) {
            long c = Long.parseLong(part);
            long m = modExp(c, d2, n2);
            decryptedMsg.append((char) m);
        }
        String receivedMsg = decryptedMsg.toString();
        System.out.println("Decrypted Message: " + receivedMsg);

        // Step 2: Hash the received message
        byte[] hashBytes2 = md.digest(receivedMsg.getBytes("UTF-8"));
        long hashReceived = 0;
        for (byte b : hashBytes2) hashReceived = (hashReceived + (b & 0xFF)) % n1;
        System.out.println("Hash of received message: " + hashReceived);

        // Step 3: Verify signature using X's public key
        long decryptedSignature = modExp(signature, e1, n1);
        System.out.println("Decrypted Signature (hash from X): " + decryptedSignature);

        // Step 4: Compare
        if (hashReceived == decryptedSignature)
            System.out.println("Signature verified. Message is authentic and unaltered.");
        else
            System.out.println("Verification failed! Message may have been tampered or fake.");

        sc.close();
    }
}
